From 93950912ea1c09b911ec2636f08a308c47fbb1d1 Mon Sep 17 00:00:00 2001
From: Vladislav Bogdanov <bubble@hoster-ok.com>
Date: Mon, 18 Oct 2010 16:10:41 +0200
Subject: [PATCH] add bonding

Format:
bond=<bondname>[:<bondslaves>:[:<options>]]

bondslaves is a comma-separated list of physical (ethernet) interfaces.

options is a comma-separated list on bonding options (modinfo bonding for
details) in format compatible with initscripts.

If options include multi-valued arp_ip_target option, then its values
should be separated by semicolon.

bond without parameters assumes bond=bond0:eth0,eth1:balance-rr

Conflicts:
	modules.d/40network/check
	modules.d/40network/install
	modules.d/40network/installkernel
	modules.d/40network/parse-bridge.sh
	modules.d/45ifcfg/write-ifcfg.sh

https://bugzilla.redhat.com/show_bug.cgi?id=851666
---
 modules.d/40network/check           |   2 +-
 modules.d/40network/ifup            |  69 +++++++++++++++++-
 modules.d/40network/install         |  14 +++-
 modules.d/40network/installkernel   |   4 +-
 modules.d/40network/net-genrules.sh |   7 ++
 modules.d/40network/parse-bond.sh   |  63 ++++++++++++++++
 modules.d/40network/parse-bridge.sh |  20 +++--
 modules.d/45ifcfg/write-ifcfg.sh    | 142 +++++++++++++++++++++++++++---------
 8 files changed, 271 insertions(+), 50 deletions(-)
 create mode 100644 modules.d/40network/parse-bond.sh

diff --git a/modules.d/40network/check b/modules.d/40network/check
index 48b7f12..a2d248a 100755
--- a/modules.d/40network/check
+++ b/modules.d/40network/check
@@ -14,7 +14,7 @@ for program in ip arping; do
     exit 1
   fi
 done
-for program in dhclient brctl; do
+for program in dhclient brctl ifenslave tr; do
   which $program >/dev/null 2>&1
   if [ $? -ne 0 ]; then
     dwarning "Could not find program \"$program\" it might be required by network." 
diff --git a/modules.d/40network/ifup b/modules.d/40network/ifup
index 2722e0f..0aa7d86 100755
--- a/modules.d/40network/ifup
+++ b/modules.d/40network/ifup
@@ -96,11 +96,25 @@ exec >>/dev/initlog.pipe 2>>/dev/initlog.pipe
 # $netif reads easier than $1
 netif=$1
 
+# enslave this interface to bond?
+if [ -e /tmp/bond.info ]; then
+    . /tmp/bond.info
+    for slave in $bondslaves ; do
+        if [ "$netif" = "$slave" ] ; then
+            netif=$bondname
+        fi
+    done
+fi
+
 # bridge this interface?
 if [ -e /tmp/bridge.info ]; then
     . /tmp/bridge.info
     if [ "$netif" = "$ethname" ]; then
-        netif="$bridgename"
+        if [ "$netif" = "$bondname" ] && [ -n "$DO_BOND_SETUP" ] ; then
+            : # We need to really setup bond (recursive call)
+        else
+            netif="$bridgename"
+        fi
     fi
 fi
 
@@ -131,11 +145,62 @@ if [ "$netif" = "lo" ] ; then
     exit 0
 fi
 
+# start bond if needed
+if [ -e /tmp/bond.info ]; then
+    . /tmp/bond.info
+
+    if [ "$netif" = "$bondname" ] && [ ! -e /tmp/net.$bondname.up ] ; then # We are master bond device
+        modprobe bonding
+        ip link set $netif down
+
+        # Stolen from ifup-eth
+        # add the bits to setup driver parameters here
+        for arg in $bondoptions ; do
+            key=${arg%%=*};
+            value=${arg##*=};
+            # %{value:0:1} is replaced with non-bash specific construct
+            if [ "${key}" = "arp_ip_target" -a "${#value}" != "0" -a "+${value%%+*}" != "+" ]; then
+                OLDIFS=$IFS;
+                IFS=',';
+                for arp_ip in $value; do
+                    echo +$arp_ip > /sys/class/net/${netif}/bonding/$key
+                done
+                IFS=$OLDIFS;
+            else
+                echo $value > /sys/class/net/${netif}/bonding/$key
+            fi
+        done
+
+        ip link set $netif up
+
+        for slave in $bondslaves ; do
+            ip link set $slave down
+            ifenslave $bondname $slave
+            ip link set $slave up
+            wait_for_if_up $slave
+        done
+
+        # add the bits to setup the needed post enslavement parameters
+        for arg in $BONDING_OPTS ; do
+            key=${arg%%=*};
+            value=${arg##*=};
+            if [ "${key}" = "primary" ]; then
+                echo $value > /sys/class/net/${netif}/bonding/$key
+            fi
+        done
+    fi
+fi
+
+
 # XXX need error handling like dhclient-script
 
 # start bridge if necessary
 if [ "$netif" = "$bridgename" ] && [ ! -e /tmp/net.$bridgename.up ]; then
-    ip link set $ethname up
+    if [ "$ethname" = "$bondname" ] ; then
+        DO_BOND_SETUP=yes /sbin/ifup $bondname
+    else
+        ip link set $ethname up
+    fi
     wait_for_if_up $ethname
     # Create bridge and add eth to bridge
     brctl addbr $bridgename
diff --git a/modules.d/40network/install b/modules.d/40network/install
index 43de2d8..a94c2a4 100755
--- a/modules.d/40network/install
+++ b/modules.d/40network/install
@@ -1,15 +1,21 @@
 #!/bin/bash
-dracut_install ip dhclient brctl arping tr
+# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
+# ex: ts=8 sw=4 sts=4 et filetype=sh
+dracut_install ip dhclient brctl arping ifenslave tr
+
 inst "$moddir/ifup" "/sbin/ifup"
 inst "$moddir/netroot" "/sbin/netroot"
 inst "$moddir/dhclient-script" "/sbin/dhclient-script"
-inst "$moddir/dhclient.conf" "/etc/dhclient.conf" 
+inst "$moddir/dhclient.conf" "/etc/dhclient.conf"
 inst_hook pre-udev 50 "$moddir/ifname-genrules.sh"
 inst_hook pre-udev 60 "$moddir/net-genrules.sh"
 inst_hook cmdline 91 "$moddir/dhcp-root.sh"
+
 inst_hook cmdline 95 "$moddir/parse-vlan.sh"
-inst_hook cmdline 97 "$moddir/parse-bridge.sh"
-inst_hook cmdline 98 "$moddir/parse-ip-opts.sh"
+inst_hook cmdline 97 "$moddir/parse-bond.sh"
+inst_hook cmdline 98 "$moddir/parse-bridge.sh"
+inst_hook cmdline 99 "$moddir/parse-ip-opts.sh"
+
 inst_hook cmdline 99 "$moddir/parse-ifname.sh"
 inst_hook pre-pivot 10 "$moddir/kill-dhclient.sh"
 
diff --git a/modules.d/40network/installkernel b/modules.d/40network/installkernel
index de2f806..0d0eb02 100755
--- a/modules.d/40network/installkernel
+++ b/modules.d/40network/installkernel
@@ -10,10 +10,12 @@ net_module_test() {
 }
 
 instmods $(filter_kernel_modules net_module_test)
-    
+
 instmods ecb arc4
 # bridge modules
 instmods bridge stp llc
 instmods ipv6
 # vlan
 instmods 8021q
+# bonding
+instmods bonding
diff --git a/modules.d/40network/net-genrules.sh b/modules.d/40network/net-genrules.sh
index 3d38152..fc303f4 100755
--- a/modules.d/40network/net-genrules.sh
+++ b/modules.d/40network/net-genrules.sh
@@ -29,6 +29,13 @@ fix_bootif() {
         IFACES="$IFACES $phydevice"
     fi
 
+    # bond: attempt only the defined interface (override bridge defines)
+    if [ -e /tmp/bond.info ]; then
+        . /tmp/bond.info
+        # It is enough to fire up only one
+        IFACES=${bondslaves%% *}
+    fi
+
     # BOOTIF says everything, use only that one
     BOOTIF=$(getarg 'BOOTIF=')
     if [ -n "$BOOTIF" ] ; then
diff --git a/modules.d/40network/parse-bond.sh b/modules.d/40network/parse-bond.sh
new file mode 100644
index 0000000..5c21bb8
--- /dev/null
+++ b/modules.d/40network/parse-bond.sh
@@ -0,0 +1,63 @@
+#!/bin/sh
+#
+# Format:
+#       bond=<bondname>[:<bondslaves>:[:<options>]]
+#
+#       bondslaves is a comma-separated list of physical (ethernet) interfaces
+#       options is a comma-separated list on bonding options (modinfo bonding for details) in format compatible with initscripts
+#       if options include multi-valued arp_ip_target option, then its values should be separated by semicolon.
+#
+#       bond without parameters assumes bond=bond0:eth0,eth1:mode=balance-rr
+#
+
+# return if bond already parsed
+[ -n "$bondname" ] && return
+
+# Check if bond parameter is valid 
+if getarg bond= >/dev/null ; then
+    if [ -z "$netroot" ] ; then
+        die "No netboot configured, bond is invalid"
+    fi
+fi
+
+# We translate list of slaves to space-separated here to mwke it easier to loop over them in ifup
+# Ditto for bonding options
+parsebond() {
+    local v=${1}:
+    set --
+    while [ -n "$v" ]; do
+        set -- "$@" "${v%%:*}"
+        v=${v#*:}
+    done
+
+    unset bondname bondslaves bondoptions
+    case $# in
+    0)  bondname=bond0; bondslaves="eth0 eth1" ;;
+    1)  bondname=$1; bondslaves="eth0 eth1" ;;
+    2)  bondname=$1; bondslaves=$(echo $2|tr "," " ") ;;
+    3)  bondname=$1; bondslaves=$(echo $2|tr "," " "); bondoptions=$(echo $3|tr "," " ") ;;
+    *)  die "bond= requires zero to four parameters" ;;
+    esac
+}
+
+unset bondname bondslaves bondoptions
+
+# Parse bond for bondname, bondslaves, bondmode and bondoptions
+if getarg bond >/dev/null; then
+    # Read bond= parameters if they exist
+    bond="$(getarg bond=)"
+    if [ ! "$bond" = "bond" ]; then 
+        parsebond "$(getarg bond=)"
+    fi
+    # Simple default bond
+    if [ -z "$bondname" ]; then
+        bondname=bond0
+        bondslaves="eth0 eth1"
+    fi
+    # Make it suitable for initscripts export
+    bondoptions=$(echo $bondoptions|tr ";" ",")
+    echo "bondname=$bondname" > /tmp/bond.info
+    echo "bondslaves=\"$bondslaves\"" >> /tmp/bond.info
+    echo "bondoptions=\"$bondoptions\"" >> /tmp/bond.info
+    return
+fi
diff --git a/modules.d/40network/parse-bridge.sh b/modules.d/40network/parse-bridge.sh
index 218485a..13242a6 100755
--- a/modules.d/40network/parse-bridge.sh
+++ b/modules.d/40network/parse-bridge.sh
@@ -26,26 +26,34 @@ parsebridge() {
 
     unset bridgename ethname
     case $# in
-    0)  bridgename=br0; ethname=eth0 ;;
-    1)  die "bridge= requires two parameters" ;;
-    2)  bridgename=$1; ethname=$2 ;;
-    *)  die "bridge= requires two parameters" ;;
+        0)  bridgename=br0; ethname=$iface ;;
+        1)  die "bridge= requires two parameters" ;;
+        2)  bridgename=$1; ethname=$2 ;;
+        *)  die "bridge= requires two parameters" ;;
     esac
 }
 
 unset bridgename ethname
 
+iface=eth0
+if [ -e /tmp/bond.info ]; then
+    . /tmp/bond.info
+    if [ -n "$bondname" ] ; then
+        iface=$bondname
+    fi
+fi
+
 # Parse bridge for bridgename and ethname
 if getarg bridge >/dev/null; then
     # Read bridge= parameters if they exist
     bridge="$(getarg bridge=)"
-    if [ ! "$bridge" = "bridge" ]; then 
+    if [ ! "$bridge" = "bridge" ]; then
         parsebridge "$(getarg bridge=)"
     fi
     # Simple default bridge
     if [ -z "$bridgename" ]; then
         bridgename=br0
-        ethname=eth0
+        ethname=$iface
     fi
     echo "bridgename=$bridgename" > /tmp/bridge.info
     echo "ethname=$ethname" >> /tmp/bridge.info
diff --git a/modules.d/45ifcfg/write-ifcfg.sh b/modules.d/45ifcfg/write-ifcfg.sh
index d0af214..a3a980b 100644
--- a/modules.d/45ifcfg/write-ifcfg.sh
+++ b/modules.d/45ifcfg/write-ifcfg.sh
@@ -1,63 +1,133 @@
 #!/bin/sh
+# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
+# ex: ts=8 sw=4 sts=4 et filetype=sh
 
 # NFS root might have reached here before /tmp/net.ifaces was written
-udevadm settle --timeout=30 >/dev/null 2>&1
+udevadm settle --timeout=30
 # Don't write anything if we don't know our bootdev
 [ -f /tmp/net.ifaces ] || return 1
 
 read IFACES < /tmp/net.ifaces
 
+if [ -e /tmp/bond.info ]; then
+    . /tmp/bond.info
+fi
+
+if [ -e /tmp/bridge.info ]; then
+    . /tmp/bridge.info
+fi
+
+mkdir -p /tmp/ifcfg/
+
 for netif in $IFACES ; do
-    mkdir -p /tmp/ifcfg/
     # bridge?
     unset bridge
+    unset bond
     if [ "$netif" = "$bridgename" ]; then
         bridge=yes
+    elif [ "$netif" = "$bondname" ]; then
+    # $netif can't be bridge and bond at the same time
+        bond=yes
     fi
     cat /sys/class/net/$netif/address > /tmp/net.$netif.hwaddr
     {
-	echo "# Generated by dracut initrd" 
-	echo "DEVICE=$netif"
-	echo "ONBOOT=yes"
-	echo "NETBOOT=yes"
-	if [ -f /tmp/net.$netif.lease ]; then
-	    strstr "$ip" '*:*:*' &&
-	    echo "DHCPV6C=yes" 
-	    echo "BOOTPROTO=dhcp" 
-	else
-	    echo "BOOTPROTO=none" 
+        echo "# Generated by dracut initrd"
+        echo "DEVICE=$netif"
+        echo "ONBOOT=yes"
+        echo "NETBOOT=yes"
+        if [ -f /tmp/net.$netif.lease ]; then
+            strstr "$ip" '*:*:*' &&
+            echo "DHCPV6C=yes"
+            echo "BOOTPROTO=dhcp"
+        else
+            echo "BOOTPROTO=none"
         # If we've booted with static ip= lines, the override file is there
-	    [ -e /tmp/net.$netif.override ] && . /tmp/net.$netif.override 
-	    echo "IPADDR=$ip"
-	    echo "NETMASK=$mask"
-	    [ -n "$gw" ] && echo "GATEWAY=$gw"
-	fi
+            . /tmp/net.$netif.override
+            echo "IPADDR=$ip"
+            echo "NETMASK=$mask"
+            [ -n "$gw" ] && echo "GATEWAY=$gw"
+        fi
     } > /tmp/ifcfg/ifcfg-$netif
 
     # bridge needs different things written to ifcfg
-    if [ -z "$bridge" ]; then
+    if [ -z "$bridge" ] && [ -z "$bond" ]; then
         # standard interface
-	{
+        {
             echo "HWADDR=$(cat /sys/class/net/$netif/address)"
             echo "TYPE=Ethernet"
-            echo "NAME=\"Boot Disk\"" 
-	} >> /tmp/ifcfg/ifcfg-$netif
-    else
+            echo "NAME=\"Boot Disk\""
+        } >> /tmp/ifcfg/ifcfg-$netif
+    fi
+
+    if [ -n "$bond" ] ; then
+        # bond interface
+        {
+            # This variable is an indicator of a bond interface for initscripts
+            echo "BONDING_OPTS=\"$bondoptions\""
+            echo "NAME=\"Boot Disk\""
+        } >> /tmp/ifcfg/ifcfg-$netif
+
+        for slave in $bondslaves ; do
+            # write separate ifcfg file for the raw eth interface
+            {
+                echo "# Generated by dracut initrd"
+                echo "DEVICE=$slave"
+                echo "TYPE=Ethernet"
+                echo "ONBOOT=yes"
+                echo "NETBOOT=yes"
+                echo "HWADDR=$(cat /sys/class/net/$slave/address)"
+                echo "SLAVE=yes"
+                echo "MASTER=$netif"
+                echo "NAME=$slave"
+            } >> /tmp/ifcfg/ifcfg-$slave
+        done
+    fi
+
+    if [ -n "$bridge" ] ; then
         # bridge
-	{
-	    echo "TYPE=Bridge"
-            echo "NAME=\"Boot Disk\"" 
-	} >> /tmp/ifcfg/ifcfg-$netif
-        # write separate ifcfg file for the raw eth interface
-	{
-            echo "DEVICE=$ethname"
-            echo "TYPE=Ethernet"
-            echo "ONBOOT=yes"
-            echo "NETBOOT=yes"
-            echo "HWADDR=$(cat /sys/class/net/$ethname/address)"
-            echo "BRIDGE=$netif"
-            echo "NAME=$ethname" 
-	} >> /tmp/ifcfg/ifcfg-$ethname
+        {
+            echo "TYPE=Bridge"
+            echo "NAME=\"Boot Disk\""
+        } >> /tmp/ifcfg/ifcfg-$netif
+        if [ "$ethname" = "$bondname" ] ; then
+            {
+                # This variable is an indicator of a bond interface for initscripts
+                echo "# Generated by dracut initrd"
+                echo "DEVICE=$bondname"
+                echo "ONBOOT=yes"
+                echo "NETBOOT=yes"
+                echo "BONDING_OPTS=\"$bondoptions\""
+                echo "BRIDGE=$netif"
+                echo "NAME=\"$bondname\""
+            } >> /tmp/ifcfg/ifcfg-$bondname
+            for slave in $bondslaves ; do
+                # write separate ifcfg file for the raw eth interface
+                # yes, duplicated code at this moment
+                {
+                    echo "# Generated by dracut initrd"
+                    echo "DEVICE=$slave"
+                    echo "TYPE=Ethernet"
+                    echo "ONBOOT=yes"
+                    echo "NETBOOT=yes"
+                    echo "HWADDR=$(cat /sys/class/net/$slave/address)"
+                    echo "SLAVE=yes"
+                    echo "MASTER=$bondname"
+                    echo "NAME=$slave"
+                } >> /tmp/ifcfg/ifcfg-$slave
+            done
+        else
+            # write separate ifcfg file for the raw eth interface
+            {
+                echo "# Generated by dracut initrd"
+                echo "DEVICE=$ethname"
+                echo "TYPE=Ethernet"
+                echo "ONBOOT=yes"
+                echo "NETBOOT=yes"
+                echo "HWADDR=$(cat /sys/class/net/$ethname/address)"
+                echo "BRIDGE=$netif"
+                echo "NAME=$ethname"
+            } >> /tmp/ifcfg/ifcfg-$ethname
+        fi
     fi
 done
 
